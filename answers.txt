# Here I have Lab3 Ready #

### at Lab 1 ###
Design Decisions/Justifications of Any Change
    at TupleTest and TupleDescTest
    - I have created ArrayList in TupleDesc. Why? -> I needed arraylike datastructure for the TDItems and the size had to be malleable.
    - I have added toString method HeapPageId and PageId to make getting the hashCode easier.

    at CatalogTest
    - I created a class called table to keep all the data for addTable in a bundle.
    - I needed some sort of way to keep multiple tables, so I chose ArrayList.

    at BufferPool
    - I am currently not thinking about the eviction of the page since in BufferPool.java, the method evict is said to be not necessary at this point.
    - This one I changed a lot after getting stuck with the last system test with HeapFile

    at HeapPageId, RecordId, HeapPageRead
    - Discussed a lot in the class, so was not really hard for me

    at HeapFile
    - I spent the most time on this phase
    - I have added HeapFileIterator in HeapFile.java -> because the DbFileIterator was just an abstract class.

    at SeqScan
    - This took me significant amount of time too, because you have to change all the other files to make this work.

Any missing or incomplete elements of my code
    I think I am fine but if the test case tests if I can evict the page or not, I am not ready yet
    (and that is because evicting page was not supposed to be implemented at this point!).

How long I spent in the lab, whether there was anything I found particularly difficult or confusing
    I spent around 30 hours total.
    I found the dependency issues always difficult to resolve, and I was consistently confused how each class interacted with each other in the begginning.
    BufferPool was particularly confusing since it doesn't even have a test until the last moment, I spent 3, 4 hours just rummaging through the code and slides
    of how they interacted with other classes.
    It was hard to debug for me, if I can run the code somehow and create a break point in an IDE to see the stack trace,
    I think I would have saved 2 hours debugging the code, especially for the last test which deals with BufferPool at the end.


### at Lab 2 ###
Design Decisions/Justification of Any Change
- I have made the page eviction policy just popping the page that is used the oldest. This was because it was simpler to implement than LRU cache, and somewhat closer to the LRU cache. I didn't want to implement the LRU because when you use the same page that you have used, you need to update the timestamp, and change the order of eviction

BufferPool.java
- I have tidConverter because flushPages took the argument tid
- page2evict is the one that decides the page to evict

Delete.java/Insert.java
- it adds calledOnce for both so that when the Operators are called two or more times, it wouldn't work

HeapFile.java/HeapPage.java
- I have added header2String and toString for debugging purposes. I left it because I will need it for the later labs.
- InsertTuple for HeapFile.java sees if there is any pages that has empty slots, if not it creates new pages and writes the page. 

- I should not have any missing part of the code.
- I spent around 15 - 20 hours on this lab.

### at Lab 3 ###
Design Decisions/Justifications for Any Change

    Aggregators should look pretty straight forward. For mergeTupleIntoGroup I first branch off into NO_GROUPING or not, and then do the necessary procedure according to which aggregate actions are necessary. In Aggregate.java, I get the IntegerAggregator/StringAggregator according to the fieldType of aggregateField, and shove in all the elements of iterator to the aggregator and return one tuple at a time when asked.

    I used the simple hash joins because I knew for sure that the memory size in the actual program is different and it would not cause thrashing, which would kill the performance. I use simple hash joins when the operators are equal, because that is what is used for the contest (and hash joins do not work well with ranged queries), and otherwise, tuple joins to handle the other cases (but this was not really requested in the contest).

    There were a couple of nasty bugs I faced. I will write those in the section below.

Bugs
    - untarring bug
        This one I wrote on the discord too. But when you untar the .tar.gz file in the Join.java, JoinPredicate.java, Insert.java, Delete.java was written on to be the initial state. So I needed to copy from my git history.

    - self join bug (which I believe many would have)
        This is a bug which I believe many people would have still. Some people would have the result of the query 3 Michael Stonebraker 14, and other people would have Michael Stonebraker 8 with some other people with count 1 instead, the latter is correct. This bug happens in LogicalPlans.java, line 475 in my code, function td.fieldNameToIndex(groupByField). Since the query is the self join this necessitates the distinction between a1.name and a2.name. Those who aggregated with a1.name will get the wrong answer and a2.name will get the right answer. The only good way is to check the table name too when fieldNameToIndex is called, but many people, including who luckily got the correct answer, have changed the string of fieldNameToIndex by omitting the table name. I have changed this in an ad hoc way to looking through the array of Strings in the reverse order, and you can definitely take some points off of me for this. However, if you do, you have to take other people's points off too if they got the right answer and not even aware of this bug.

Time for each query
    query 1. 0.25 seconds 
    query 2. 0.47 seconds
    query 3. 1.11 seconds
